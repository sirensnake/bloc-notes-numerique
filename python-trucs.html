<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>🐍 Python - Trucs & astuces</title>
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="css/style-python.css">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
</head>

<body>
  <header>
    <div class="banner-container">
      <img src="img/banner.png" alt="Bannière du site" class="banner-img">
    </div>
    <h1>🐍 Python : Trucs & astuces</h1>
    <nav>
      <ul class="main-menu">
        <li><a href="index.html">🏠 Accueil</a></li>
        <li class="dropdown">
          <a href="#">📚 Python ▼</a>
          <ul class="submenu">
            <li><a href="python-bases.html">📘 Bases</a></li>
            <li><a href="python-collections.html">🗂️ Collections</a></li>
            <li><a href="python-controle.html">🔁 Contrôle</a></li>
            <li><a href="python-erreurs.html">❌ Erreurs</a></li>
            <li><a href="python-fichiers.html">📂 Fichiers</a></li>
            <li><a href="python-fonctions.html">🛠️ Fonctions</a></li>
            <li><a href="python-modules.html">🧩 Modules</a></li>
            <li><a href="python-poo.html">🏛️ POO</a></li>
            <li><a href="python-trucs.html">🧠 Trucs</a></li>
          </ul>
        </li>
      </ul>
    </nav>
  </header>

  <main>
    <section class="intro">
      <p>Cette fiche rassemble des <strong>astuces pratiques</strong> et des <strong>techniques avancées</strong> pour améliorer votre code Python, optimiser vos scripts, et utiliser le langage de manière plus efficace au quotidien.</p>
    </section>

    <details class="sommaire">
      <summary>📑 Sommaire</summary>
      <ul>
        <li><a href="#walrus">Opérateur d'affectation d'expression (:=)</a></li>
        <li><a href="#comprehensions">Compréhensions avancées</a></li>
        <li><a href="#deballage">Déballage multiple</a></li>
        <li><a href="#exceptions">Gestion fine des exceptions</a></li>
        <li><a href="#performance">Mesurer la performance</a></li>
        <li><a href="#bonus">Bonus</a></li>
      </ul>
    </details>

    <section id="walrus">
      <h2>🪄 L'opérateur "walrus" (:=)</h2>
      <p>Introduit avec Python 3.8, cet opérateur permet de réaliser une affectation dans une expression :</p>
      <pre><code># Sans opérateur walrus
texte = input("Entrez un texte : ")
if len(texte) > 0:
    print(f"Vous avez saisi {len(texte)} caractères")

# Avec opérateur walrus
if (n := len(input("Entrez un texte : "))) > 0:
    print(f"Vous avez saisi {n} caractères")</code></pre>
      <p>Très utile dans les conditions, les boucles while et les compréhensions :</p>
      <pre><code># Traiter des lignes jusqu'à une ligne vide
while (ligne := input()) != "":
    print(f"Traitement de : {ligne}")

# Filtrer des résultats avec une condition complexe
resultats = [resultat for x in data if (resultat := f(x)) > 0]</code></pre>
    </section>

    <section id="comprehensions">
      <h2>🚀 Compréhensions avancées</h2>
      <p>Les compréhensions permettent d'écrire du code concis et expressif :</p>
      <pre><code># Compréhension de liste avec conditions
nombres = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
cubes_pairs = [x**3 for x in nombres if x % 2 == 0]
print(cubes_pairs)  # [8, 64, 216, 512, 1000]

# Compréhension imbriquée (matrice 3x3)
matrice = [[i*3+j+1 for j in range(3)] for i in range(3)]
print(matrice)  # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Compréhension de dictionnaire avec condition
carre_pairs = {x: x**2 for x in range(10) if x % 2 == 0}
print(carre_pairs)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}

# Compréhension d'ensemble avec transformation
voyelles = {lettre.upper() for lettre in "bonjour" if lettre in "aeiouy"}
print(voyelles)  # {'O', 'U'}</code></pre>
    </section>

    <section id="deballage">
      <h2>⚙️ Déballage multiple</h2>
      <p>Le déballage (unpacking) permet d'extraire des valeurs de séquences de manière élégante :</p>
      <pre><code># Déballage simple
a, b, c = [1, 2, 3]
print(a, b, c)  # 1 2 3

# Ignorer certaines valeurs avec _
a, _, c = [1, 2, 3]
print(a, c)  # 1 3

# Déballage avec * (reste dans une liste)
premier, *milieu, dernier = [1, 2, 3, 4, 5]
print(premier)   # 1
print(milieu)    # [2, 3, 4]
print(dernier)   # 5

# Échanger des valeurs sans variable temporaire
a, b = 10, 20
a, b = b, a
print(a, b)  # 20 10

# Déballage de dictionnaire avec **
def afficher_infos(nom, age, ville):
    print(f"{nom}, {age} ans, habite à {ville}")

personne = {"nom": "Alice", "age": 30, "ville": "Paris"}
afficher_infos(**personne)  # Alice, 30 ans, habite à Paris</code></pre>
    </section>

    <section id="exceptions">
      <h2>🪤 Gestion fine des exceptions</h2>
      <p>Capturez et gérez précisément les différents types d'erreurs :</p>
      <pre><code># Capture multiple d'exceptions
try:
    valeur = int(input("Entrez un nombre : "))
    resultat = 10 / valeur
    print(f"Résultat : {resultat}")
except ValueError:
    print("Ceci n'est pas un nombre valide")
except ZeroDivisionError:
    print("Division par zéro impossible")
except Exception as e:
    print(f"Erreur inattendue : {e}")
else:
    print("Aucune erreur n'est survenue")
finally:
    print("Cette partie s'exécute toujours")</code></pre>
      
      <p>Grouper plusieurs exceptions :</p>
      <pre><code>try:
    # Code susceptible de générer des erreurs
    pass
except (ValueError, TypeError) as e:
    print(f"Erreur de type : {e}")</code></pre>
    </section>

    <section id="performance">
      <h2>⏱️ Mesurer la performance</h2>
      <p>Plusieurs façons de mesurer le temps d'exécution de votre code :</p>
      <pre><code># Méthode simple avec time
import time

start = time.time()
# ... votre code ...
end = time.time()
print(f"Durée : {end - start:.4f} secondes")</code></pre>
      
      <p>Utilisation de <code>timeit</code> pour des mesures précises :</p>
      <pre><code>import timeit

# Mesurer une ligne
temps = timeit.timeit('[x**2 for x in range(1000)]', number=10000)
print(f"Temps d'exécution : {temps:.4f} secondes")

# Mesurer une fonction
def ma_fonction():
    return sum(x**2 for x in range(1000))
    
temps = timeit.timeit(ma_fonction, number=10000)
print(f"Temps d'exécution : {temps:.4f} secondes")</code></pre>
      
      <p>Décorateur pour profiler une fonction :</p>
      <pre><code>def chronometre(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} a pris {end - start:.4f} secondes")
        return result
    return wrapper

@chronometre
def operation_couteuse():
    time.sleep(1)  # Simuler une opération longue
    return "Terminé"
    
operation_couteuse()  # Affiche : operation_couteuse a pris 1.0012 secondes</code></pre>
    </section>

    <details id="bonus" class="bonus">
      <summary>🎁 Bonus : Astuces avancées</summary>
      
      <h3>Chaînes f (f-strings) avec formatage avancé</h3>
      <pre><code># Format avec la spécification de précision
nombre = 123.456789
print(f"{nombre:.2f}")  # 123.46

# Alignement et remplissage
for i in range(1, 11):
    print(f"{i:03d} - {i*i:4d} - {i*i*i:5d}")

# Formatage de dates
from datetime import datetime
maintenant = datetime.now()
print(f"{maintenant:%d/%m/%Y %H:%M}")  # Ex: 27/04/2025 14:30

# Débogage facile
x = 10
y = 20
print(f"{x=}, {y=}, {x+y=}")  # x=10, y=20, x+y=30</code></pre>
      
      <h3>Collections spécialisées</h3>
      <pre><code>from collections import Counter, defaultdict, namedtuple

# Counter pour compter les occurrences
texte = "abracadabra"
compteur = Counter(texte)
print(compteur)  # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
print(compteur.most_common(2))  # [('a', 5), ('b', 2)]

# defaultdict pour des valeurs par défaut
fruits_par_couleur = defaultdict(list)
fruits_par_couleur["rouge"].append("pomme")  # Pas d'erreur même si la clé n'existe pas
fruits_par_couleur["rouge"].append("fraise")
print(fruits_par_couleur)  # defaultdict(<class 'list'>, {'rouge': ['pomme', 'fraise']})

# namedtuple pour des tuples avec noms de champs
Point = namedtuple('Point', ['x', 'y'])
p = Point(10, 20)
print(p.x, p.y)  # 10 20
print(p)  # Point(x=10, y=20)</code></pre>
      
      <h3>Trucs pour le débogage</h3>
      <pre><code># Utiliser pdb, le débogueur intégré
import pdb

def fonction_complexe(x):
    y = x * 2
    pdb.set_trace()  # Le programme s'arrête ici et entre en mode débogage
    z = y * 3
    return z

# Utiliser `breakpoint()` (Python 3.7+) à la place de pdb.set_trace()
def autre_fonction(x):
    y = x * 2
    breakpoint()  # Équivalent à pdb.set_trace()
    z = y * 3
    return z</code></pre>
    </details>

    <div class="bottom-buttons">
      <a class="button-return" href="index.html">🏠 Retour au sommaire général</a>
      <button class="button" onclick="window.print()">🖨️ Exporter en PDF</button>
    </div>
  </main>

  <footer>
    <p>© 2025 Guillaume | Bloc-Note Technique 📚</p>
  </footer>

</body>
</html>